name: Build Source RPM (for COPR/Manual Upload)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

# Add permissions block to allow the workflow to read the uploaded artifact
# and use secrets for COPR authentication.
permissions:
  contents: read
  id-token: write # Required for some newer COPR actions, safe to include.

jobs:
  build_source_rpm:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        # Ensures the winboat.spec file is present

      - name: Set Version, Update USB IDs, and Create Source Tarball
        id: prep
        run: |
          # 1. Extract version number (assuming it's in package.json)
          # Note: If no package.json, you MUST manually set the version here.
          VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.0.1")
          
          # 2. Update USB IDs database (CRITICAL STEP from release.yml)
          # Ensure 'data' directory exists, then download the latest file
          mkdir -p data
          echo "Removing old usb.ids file..."
          rm -f data/usb.ids || true
          echo "Attempting to download latest usb.ids from linux-usb.org..."
          
          # Implement robust download with HTTPS preference and HTTP fallback
          DOWNLOAD_URL_HTTPS="https://www.linux-usb.org/usb.ids"
          DOWNLOAD_URL_HTTP="http://www.linux-usb.org/usb.ids"
          
          if curl -sS -f -o data/usb.ids "$DOWNLOAD_URL_HTTPS"; then
              echo "USB IDs database updated successfully via HTTPS."
          elif curl -sS -f -o data/usb.ids "$DOWNLOAD_URL_HTTP"; then
              echo "USB IDs database updated successfully via HTTP fallback."
          else
              # If both fail, issue a warning and continue, as this is often transient.
              echo "::warning::Could not download usb.ids from either source. Proceeding with existing or missing file."
          fi
          
          # 3. Create the Source Tarball, including the new data/usb.ids file
          TARBALL_NAME="winboat-$VERSION.tar.gz"
          TARBALL_PATH="/tmp/$TARBALL_NAME" # Define a path outside the source tree
          echo "Creating $TARBALL_NAME and writing to $TARBALL_PATH..."
          # FIX: Write the tarball to /tmp to avoid the 'file changed as we read it' error.
          # We archive the current directory (.), but write the output to /tmp.
          tar -czvf "$TARBALL_PATH" \
            --exclude=.git \
            --exclude=node_modules .
          
          # Pass the tarball path and version to later steps
          echo "VERSION=$VERSION" >> "$GITHUB_OUTPUT"
          echo "TARBALL_PATH=$TARBALL_PATH" >> "$GITHUB_OUTPUT"

      - name: Install RPM Build Tools
        run: |
          # Ensure package lists are up-to-date
          sudo apt-get update
          # We install 'rpm' (which provides rpmbuild) and 'build-essential' for fundamental tools.
          sudo apt-get install -y rpm build-essential
          echo "Installed RPM tools and dependencies successfully."

      - name: Create RPM Build Environment
        id: create_env
        run: |
          # Create the mandatory directory structure for rpmbuild
          mkdir -p ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
          
          # FIX: Dynamically find the .spec file anywhere in the repository and copy it
          SPEC_FILE=$(find . -iname "*.spec" -print -quit)

          if [ -z "$SPEC_FILE" ]; then
            echo "::error::winboat.spec not found. Please ensure a .spec file exists in your repository."
            exit 1
          fi
          
          echo "Found spec file: $SPEC_FILE"
          
          # Get the filename (basename) of the spec file
          SPEC_FILENAME=$(basename "$SPEC_FILE")
          
          # Copy the found spec file into the SPECS directory
          cp "$SPEC_FILE" ~/rpmbuild/SPECS/
          
          # Retrieve and copy the source tarball from /tmp into the SOURCES directory
          TARBALL_PATH="${{ steps.prep.outputs.TARBALL_PATH }}"

          # CRITICAL CHECK: Ensure the tarball exists before copying
          if [ ! -f "$TARBALL_PATH" ]; then
            echo "::error::Source tarball was not created at $TARBALL_PATH in the previous step. Stopping build."
            exit 1
          fi

          echo "Copying tarball from $TARBALL_PATH to ~/rpmbuild/SOURCES/"
          cp "$TARBALL_PATH" ~/rpmbuild/SOURCES/
          
          # Pass the SPEC_FILENAME to the next step via GITHUB_OUTPUT
          echo "SPEC_FILENAME=$SPEC_FILENAME" >> "$GITHUB_OUTPUT"

      - name: Generate Source RPM (.src.rpm)
        id: generate_srpm
        run: |
          # Retrieve the necessary variables
          SPEC_FILENAME="${{ steps.create_env.outputs.SPEC_FILENAME }}"
          VERSION="${{ steps.prep.outputs.VERSION }}"
          SPEC_PATH="$HOME/rpmbuild/SPECS/$SPEC_FILENAME" # Use $HOME for consistency
          
          # 1. Inject the dynamic version number into the spec file
          # This replaces the __VERSION__ placeholder in the Version and Changelog fields.
          echo "Setting version $VERSION in $SPEC_PATH"
          sed -i "s/__VERSION__/$VERSION/g" "$SPEC_PATH"

          # 2. CRITICAL FIX: Ensure Source0 uses the correct RPM macro %{version} 
          # This overrides any lingering placeholders or literal strings in the Source0 tag.
          echo "Fixing Source0 tag to use %{name}-%{version}.tar.gz."
          sed -i "s/^Source0:.*/Source0:        %{name}-%{version}.tar.gz/" "$SPEC_PATH"

          # 3. Run the build
          # The -bs flag tells rpmbuild to 'Build Source' package only.
          rpmbuild -bs "$SPEC_PATH"
          
          # Find the generated SRPM file path for the next step
          SRPM_FILE=$(find "$HOME/rpmbuild/SRPMS" -name "*.src.rpm" -print -quit)
          echo "SRPM_FILE_PATH=$SRPM_FILE" >> "$GITHUB_OUTPUT"

      - name: Upload Source RPM Artifact
        uses: actions/upload-artifact@v4
        with:
          name: winboat-srpm
          path: ~/rpmbuild/SRPMS/*.src.rpm
          
      - name: Submit SRPM to COPR via cURL (Bypassing Action Dependency)
        id: submit_copr
        run: |
          SRPM_PATH="${{ steps.generate_srpm.outputs.SRPM_FILE_PATH }}"
          COPR_PROJECT="stevensko/winboat" # Use the assumed working name
          API_ENDPOINT="https://copr.fedorainfracloud.org/api_3/builds/upload/"
          
          echo "Submitting SRPM to COPR project $COPR_PROJECT at $SRPM_PATH..."
          
          # Use curl to submit the SRPM directly to the COPR API.
          # -w "\nHTTP_CODE: %{http_code}\n": Prints the HTTP status code at the end.
          RESPONSE=$(curl -sS -w "\nHTTP_CODE: %{http_code}\n" -X POST \
            -F "pkgs=@$SRPM_PATH" \
            -F "project=$COPR_PROJECT" \
            -H "Authorization: token ${{ secrets.COPR_API_TOKEN }}" \
            "$API_ENDPOINT")
            
          # Print the COPR API response for debugging
          echo "COPR API Response:"
          echo "$RESPONSE"
          
          # Check the HTTP status code (last 3 digits of the response line)
          # We use grep -oE to reliably extract the 3-digit code
          HTTP_CODE=$(echo "$RESPONSE" | tail -n 1 | grep -oE '[0-9]{3}')

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
              echo "::notice::COPR submission complete (HTTP $HTTP_CODE). Check the COPR project page for build status."
          elif [ "$HTTP_CODE" -eq 403 ] || [ "$HTTP_CODE" -eq 401 ]; then
              echo "::error::COPR Submission Failed (HTTP $HTTP_CODE - Forbidden/Unauthorized). Your COPR_API_TOKEN is incorrect, expired, or lacks 'Write' permissions for the project '$COPR_PROJECT'."
              exit 1
          elif [ "$HTTP_CODE" -eq 404 ]; then
              echo "::error::COPR Submission Failed (HTTP $HTTP_CODE - Not Found). The project '$COPR_PROJECT' may not exist or the name is incorrect. (COPR often returns 404 for permission/token issues too)."
              exit 1
          else
              echo "::error::COPR Submission Failed (HTTP $HTTP_CODE). See API Response above for details. If the code is 000, the token or URL is likely invalid."
              exit 1
          fi
